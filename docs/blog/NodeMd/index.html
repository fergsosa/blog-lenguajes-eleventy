<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js</title>
    <meta name="description" content="Ideas principales de Node.js">
    <link rel="icon" href="/blog-lenguajes-eleventy/img/icono.ico">
    <link rel="stylesheet" href="/blog-lenguajes-eleventy/css/styles-post.css">
  </head>
  <body>
    <header>
  <nav class="navbar">
  <div class="grir-parent">
    <div class="grid-item">
      <a href="/blog-lenguajes-eleventy/" class="logo"> FerBlog </a>
      <div class="menu">
          <a href="/blog-lenguajes-eleventy/">Inicio</a>
          <a href="/blog-lenguajes-eleventy/blog">Blog</a>
      </div>
    </div>
  </div>
</nav>
</header>
    <main>
      <h1 id="node-js">Node.js</h1>
<p><img src="/blog-lenguajes-eleventy/img/portada/node.avif" alt="Node.js"></p>
<h2 id="que-es-node-js-y-en-que-se-diferencia-de-otros">¿Qué es Node.js y en qué se diferencia de otros?</h2>
<p>Node.js es un <strong>entorno de ejecución de JavaScript</strong> que se ejecuta <strong>fuera del navegador</strong>, construido sobre el motor V8 de Google Chrome.<br>
Permite usar JavaScript en el <strong>lado del servidor</strong> para crear aplicaciones escalables y rápidas.</p>
<h4 id="diferencias-clave">Diferencias clave:</h4>
<ul>
<li>
<p><strong>Asincronía y no bloqueo:</strong> Usa un modelo basado en eventos y callbacks, ideal para manejar múltiples conexiones simultáneamente.</p>
</li>
<li>
<p><strong>Un solo lenguaje:</strong> Permite usar JavaScript tanto en el front-end como en el back-end.</p>
</li>
<li>
<p><strong>Módulos integrados:</strong> Viene con módulos como <code>http</code>, <code>fs</code> o <code>path</code> para construir servidores y trabajar con el sistema operativo sin dependencias externas.</p>
</li>
<li>
<p><strong>Comunidad y ecosistema:</strong> Cuenta con NPM, uno de los gestores de paquetes más grandes del mundo.</p>
</li>
</ul>
<h2 id="para-que-se-usa-y-en-que-contextos">¿Para qué se usa y en qué contextos?</h2>
<p>Node.js se utiliza principalmente para <strong>aplicaciones que necesitan alta concurrencia</strong> y operaciones en tiempo real, como:</p>
<ul>
<li>APIs y servicios REST o GraphQL.</li>
<li>Aplicaciones de chat y mensajería instantánea.</li>
<li>Streaming de video o audio.</li>
<li>Dashboards en tiempo real.</li>
<li>Microservicios y arquitecturas escalables.</li>
</ul>
<p><strong>Mejor contexto:</strong> cuando hay muchas operaciones de <strong>entrada/salida (I/O)</strong> y se busca eficiencia sin bloquear procesos.</p>
<h2 id="que-puedo-construir-con-node-js">¿Qué puedo construir con Node.js?</h2>
<p>Con Node.js se pueden crear distintos tipos de aplicaciones, por ejemplo:</p>
<ul>
<li>
<p><strong>Backend de aplicaciones web:</strong> REST API, GraphQL.</p>
</li>
<li>
<p><strong>Sistemas en tiempo real:</strong> chat, juegos multijugador, notificaciones en vivo.</p>
</li>
<li>
<p><strong>Aplicaciones de streaming:</strong> Netflix, Spotify, etc.</p>
</li>
<li>
<p><strong>Automatizaciones y scripts:</strong> bots, web scraping, herramientas CLI.</p>
</li>
<li>
<p><strong>Microservicios y arquitecturas distribuidas.</strong></p>
</li>
<li>
<p><strong>Aplicaciones serverless:</strong> con plataformas como AWS Lambda o Vercel.</p>
</li>
</ul>
<h2 id="cuando-es-mas-conveniente-usarlo">¿Cuándo es más conveniente usarlo?</h2>
<h4 id="conviene-usar-node-js-cuando">Conviene usar Node.js cuando:</h4>
<ul>
<li>Se requiere <strong>alto rendimiento en I/O</strong>, como bases de datos, APIs, sockets.</li>
<li>Se busca un lenguaje unificado (JavaScript) para <strong>frontend y backend</strong>.</li>
<li>El proyecto necesita <strong>escalabilidad horizontal</strong> (agregar más servidores fácilmente).</li>
<li>El desarrollo debe ser <strong>rápido</strong> gracias a la gran cantidad de librerías en NPM.</li>
</ul>
<h4 id="no-es-la-mejor-opcion-cuando">No es la mejor opción cuando:</h4>
<ul>
<li>Se realizan <strong>cálculos intensivos</strong> o procesamiento muy pesado de CPU.</li>
<li>El sistema requiere <strong>operaciones complejas y secuenciales</strong> que no se benefician de la asincronía.</li>
<li>El equipo no tiene experiencia en asincronía y manejo de promesas.</li>
</ul>
<h2 id="buenas-practicas-y-patrones-recomendados-para-node-js">Buenas prácticas y patrones recomendados para Node.js</h2>
<ul>
<li>
<p><strong>Estructura modular:</strong> separar el proyecto en controladores, rutas, servicios y utilidades.</p>
</li>
<li>
<p><strong>Uso de Promesas y <code>async/await</code>:</strong> para escribir código más limpio y legible.</p>
</li>
<li>
<p><strong>Validar datos:</strong> nunca confiar en la entrada del usuario. Usar librerías como <code>Joi</code> o <code>Zod</code>.</p>
</li>
<li>
<p><strong>Manejo de errores centralizado:</strong> middleware para capturar y gestionar errores.</p>
</li>
<li>
<p><strong>Variables de entorno (<code>.env</code>):</strong> no hardcodear credenciales ni configuraciones sensibles.</p>
</li>
<li>
<p><strong>Logging:</strong> usar herramientas como <code>Winston</code> o <code>Pino</code> para depuración y monitoreo.</p>
</li>
<li>
<p><strong>Seguridad:</strong></p>
<ul>
<li>Usar <code>helmet</code> para proteger cabeceras HTTP.</li>
<li>Sanitizar inputs para evitar inyecciones.</li>
<li>Mantener dependencias actualizadas.</li>
</ul>
</li>
<li>
<p><strong>Tests automatizados:</strong> Mocha, Jest o Vitest para asegurar calidad del código.</p>
</li>
<li>
<p><strong>Patrones recomendados:</strong></p>
<ul>
<li>MVC (Modelo-Vista-Controlador) para organizar el código.</li>
<li>Repository Pattern para manejo de datos.</li>
<li>Middleware Pattern para modularizar la lógica.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="resumen-final">Resumen final</h2>
<ul>
<li>
<p><strong>Fortalezas principales:</strong></p>
<ul>
<li>Excelente rendimiento para aplicaciones con alta concurrencia.</li>
<li>Un solo lenguaje para front-end y back-end.</li>
<li>Gran ecosistema con miles de paquetes en NPM.</li>
<li>Perfecto para aplicaciones en tiempo real y APIs escalables.</li>
</ul>
</li>
<li>
<p><strong>Debilidades principales:</strong></p>
<ul>
<li>No es ideal para tareas muy pesadas en CPU.</li>
<li>La asincronía puede ser difícil de manejar si el equipo no tiene experiencia.</li>
<li>Dependencias externas pueden generar problemas de seguridad si no se controlan.</li>
</ul>
</li>
<li>
<p><strong>Cuándo usarlo:</strong></p>
<ul>
<li>APIs, microservicios, aplicaciones en tiempo real (chat, streaming, dashboards).</li>
<li>Proyectos donde se busca rapidez en desarrollo y escalabilidad.</li>
</ul>
</li>
<li>
<p><strong>Cuándo evitarlo:</strong></p>
<ul>
<li>Procesamiento intensivo como inteligencia artificial, renderizado 3D o cálculos matemáticos complejos.</li>
<li>Sistemas que requieren lógica de negocio muy secuencial y pesada.</li>
</ul>
</li>
</ul>
<hr>
<h1 id="conceptos-relacionados">Conceptos relacionados</h1>
<h3 id="que-es-un-orm">¿Qué es un ORM?</h3>
<p>Object Relational Mapper: herramienta que permite interactuar con bases de datos usando objetos y métodos en lugar de SQL directo (ejemplo: Sequelize, TypeORM, Prisma).</p>
<h3 id="que-es-una-api">¿Qué es una API?</h3>
<p>Application Programming Interface: conjunto de reglas que permite que dos aplicaciones se comuniquen. En el contexto web suele ser un servicio que expone datos y funcionalidades.</p>
<h3 id="que-es-el-patron-rest">¿Qué es el patrón REST?</h3>
<p>Estilo de arquitectura para construir APIs que utiliza <code>HTTP</code> y operaciones como <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> siguiendo convenciones en las rutas y respuestas.</p>
<h3 id="que-es-serverless">¿Qué es Serverless?</h3>
<p>Modelo en el que no administras servidores, sino que el proveedor (ej: AWS Lambda, Firebase Functions) ejecuta funciones bajo demanda y escala automáticamente.</p>
<h3 id="que-es-arquitectura-de-microservicios">¿Qué es arquitectura de Microservicios?</h3>
<p>Es un estilo donde una aplicación grande se divide en pequeños servicios independientes, cada uno con su propia lógica y base de datos, que se comunican entre sí (generalmente vía APIs).</p>
<hr>
<h1 id="herramientas-recomendadas">Herramientas recomendadas</h1>
<h2 id="1-frameworks-para-aplicaciones-web">1. Frameworks para aplicaciones web</h2>
<ul>
<li>
<p><strong>Express.js</strong></p>
<ul>
<li>Framework minimalista y flexible para construir APIs y aplicaciones web.</li>
<li>Muy popular y con gran ecosistema de middleware.</li>
</ul>
</li>
<li>
<p><strong>Fastify</strong></p>
<ul>
<li>Alternativa a Express, más rápida y optimizada para alto rendimiento.</li>
<li>Compatible con plugins y validaciones de esquema.</li>
</ul>
</li>
<li>
<p><strong>NestJS</strong></p>
<ul>
<li>Framework estructurado, basado en TypeScript y patrones como MVC y Dependency Injection.</li>
<li>Ideal para aplicaciones grandes y escalables.</li>
</ul>
</li>
<li>
<p><strong>Koa.js</strong></p>
<ul>
<li>Framework minimalista creado por los mismos autores de Express.</li>
<li>Enfocado en la modernidad y uso de <code>async/await</code>.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-frameworks-para-tiempo-real">2. Frameworks para tiempo real</h2>
<ul>
<li>
<p><strong>Socket.io</strong></p>
<ul>
<li>Para comunicación bidireccional en tiempo real (chat, notificaciones, juegos).</li>
</ul>
</li>
<li>
<p><strong>ws</strong></p>
<ul>
<li>Implementación más ligera de WebSockets.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-bases-de-datos-y-orm-odm">3. Bases de datos y ORM/ODM</h2>
<ul>
<li>
<p><strong>Mongoose</strong></p>
<ul>
<li>ODM para MongoDB, facilita la validación y modelado de datos.</li>
</ul>
</li>
<li>
<p><strong>Sequelize</strong></p>
<ul>
<li>ORM para bases de datos SQL (PostgreSQL, MySQL, SQLite).</li>
</ul>
</li>
<li>
<p><strong>Prisma</strong></p>
<ul>
<li>ORM moderno y tipado, ideal para TypeScript.</li>
<li>Manejo sencillo de migraciones y consultas complejas.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-testing-y-calidad">4. Testing y calidad</h2>
<ul>
<li>
<p><strong>Jest</strong></p>
<ul>
<li>Framework de testing completo para unit y integration tests.</li>
</ul>
</li>
<li>
<p><strong>Mocha + Chai</strong></p>
<ul>
<li>Combinación clásica para tests y aserciones.</li>
</ul>
</li>
<li>
<p><strong>Vitest</strong></p>
<ul>
<li>Alternativa rápida para proyectos modernos con TypeScript.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-utilidades-y-herramientas-de-desarrollo">5. Utilidades y herramientas de desarrollo</h2>
<ul>
<li>
<p><strong>Nodemon</strong></p>
<ul>
<li>Reinicia automáticamente la app cuando detecta cambios en el código.</li>
</ul>
</li>
<li>
<p><strong>PM2</strong></p>
<ul>
<li>Gestor de procesos para producción, monitorización y balanceo de carga.</li>
</ul>
</li>
<li>
<p><strong>dotenv</strong></p>
<ul>
<li>Manejo de variables de entorno desde archivos <code>.env</code>.</li>
</ul>
</li>
<li>
<p><strong>ESLint + Prettier</strong></p>
<ul>
<li>Linter y formateador para mantener código limpio y consistente.</li>
</ul>
</li>
<li>
<p><strong>Swagger / OpenAPI</strong></p>
<ul>
<li>Documentación interactiva para APIs REST.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-seguridad-y-autenticacion">6. Seguridad y autenticación</h2>
<ul>
<li>
<p><strong>Helmet</strong></p>
<ul>
<li>Protección de cabeceras HTTP.</li>
</ul>
</li>
<li>
<p><strong>Cors</strong></p>
<ul>
<li>Configuración de políticas de seguridad en peticiones HTTP.</li>
</ul>
</li>
<li>
<p><strong>Passport.js</strong></p>
<ul>
<li>Autenticación con estrategias múltiples (JWT, OAuth, Google, etc).</li>
</ul>
</li>
<li>
<p><strong>jsonwebtoken (JWT)</strong></p>
<ul>
<li>Para autenticación basada en tokens.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>Estas herramientas combinadas permiten construir aplicaciones Node.js <strong>seguras, escalables y mantenibles</strong>, desde prototipos rápidos hasta sistemas de gran escala.</p>
</blockquote>
<h1 id="conceptos">Conceptos</h1>
<ul>
<li><strong>Modelo cliente / servidor</strong>: solicitudes</li>
<li><strong>Patrón de software</strong>: MVC (modelo vista controlador)</li>
<li><strong>API REST</strong>: CRUD: GET / POST / PUT / DELETE</li>
</ul>
<h2 id="conceptos-basicos">Conceptos Básicos</h2>
<ul>
<li><strong>Entorno de Ejecución</strong>: <em>( Ejecución de JavaScript en servidor )</em></li>
</ul>
<p>Node.js proporciona un entorno de tiempo de ejecución para JavaScript fuera del navegador, lo que significa que puedes ejecutar JavaScript en el servidor.</p>
<ul>
<li><strong>Event-Driven y Non-Blocking I/O</strong> <em>( Programación orientada a eventos, E/S no bloqueante )</em></li>
</ul>
<p>Node.js utiliza un modelo de programación orientado a eventos y operaciones de entrada/salida no bloqueante, lo que permite manejar múltiples solicitudes simultáneamente sin bloquear el hilo de ejecución.</p>
<ul>
<li><strong>Módulos</strong> <em>( División de la aplicación en módulos reutilizables )</em></li>
</ul>
<p>Node.js utiliza un sistema de módulos que permite la modularidad en el código. Puedes dividir tu aplicación en archivos pequeños y reutilizables, y luego importarlos según sea necesario en otros archivos.</p>
<ul>
<li><strong>npm: Node Package Manager</strong> <em>( Gestión de paquetes y dependencias con npm )</em></li>
</ul>
<p>Es el sistema de gestión de paquetes de Node.js que te permite instalar, compartir y gestionar dependencias de proyectos fácilmente. npm es una de las mayores colecciones de paquetes de código abierto del mundo.</p>
<ul>
<li><strong>API de E/S Asíncrona</strong> <em>( Operaciones de entrada/salida asíncronas )</em></li>
</ul>
<p>Node.js proporciona una amplia gama de APIs para realizar operaciones de entrada/salida de manera asíncrona, lo que significa que las operaciones pueden continuar mientras otras operaciones están en curso, sin bloquear el hilo de ejecución.</p>
<ul>
<li><strong>Single-Threaded pero Event-Loop</strong> <em>( Modelo de event-loop para concurrencia eficiente )</em></li>
</ul>
<p>Node.js opera en un solo hilo, pero utiliza un modelo de event-loop que permite manejar múltiples solicitudes simultáneamente. Esto hace que sea eficiente para aplicaciones de red en tiempo real.</p>
<ul>
<li><strong>Escalabilidad</strong> <em>( Altamente escalable para aplicaciones de red )</em></li>
</ul>
<p>Gracias a su modelo de E/S no bloqueante y su capacidad para manejar muchas conexiones simultáneas, Node.js es altamente escalable y adecuado para aplicaciones que requieren un alto rendimiento y concurrencia.</p>
<ul>
<li><strong>Desarrollo de API y Aplicaciones Web</strong> <em>( Desarrollo de APIs, servidores web, aplicaciones en tiempo real )</em></li>
</ul>
<p>Node.js es comúnmente utilizado para desarrollar APIs RESTful, servidores web y aplicaciones de una sola página (SPA), así como aplicaciones en tiempo real como chat en línea, juegos multijugador y aplicaciones de transmisión de datos.</p>
<ul>
<li><strong>Frameworks y Bibliotecas</strong> <em>( Utilización de frameworks y bibliotecas populares )</em></li>
</ul>
<p>Existen muchos frameworks y bibliotecas populares construidos sobre Node.js, como Express.js, Socket.io, Hapi.js, Koa.js, entre otros, que simplifican el desarrollo web y la creación de APIs.</p>
<ul>
<li><strong>Streaming de Datos</strong> <em>( Eficiente para streaming de datos en tiempo real )</em></li>
</ul>
<p>Node.js es excelente para el manejo de datos en tiempo real, como el streaming de archivos o la transmisión de video, debido a su capacidad para manejar la E/S de manera eficiente.</p>
<ul>
<li><strong>Middleware</strong> <em>( Funciones que manejan solicitudes HTTP intermedias )</em></li>
</ul>
<p>Son funciones intermedias que se ejecutan entre la recepción de una solicitud HTTP y el envío de una respuesta. En el contexto de Node.js y frameworks como Express.js, los middlewares pueden realizar tareas como el análisis del cuerpo de la solicitud, la autenticación, la gestión de sesiones, el registro de solicitudes, entre otros.</p>
<ul>
<li><strong>Callback</strong> <em>( Funciones pasadas como argumentos a otras funciones )</em></li>
</ul>
<p>En JavaScript, un callback es una función que se pasa como argumento a otra función y se ejecuta después de que la función principal ha terminado de ejecutarse. Son comunes en Node.js para manejar operaciones asíncronas como lectura de archivos, solicitudes de red o consultas a bases de datos.</p>
<ul>
<li><strong>Promesa</strong> <em>( Manejo asincrónico de operaciones, evita &quot;callback hell&quot; )</em></li>
</ul>
<p>Son objetos que representan el éxito o el fracaso eventual de una operación asíncrona y su valor resultante. Las promesas en Node.js proporcionan una forma más limpia y estructurada de manejar operaciones asincrónicas, evitando el &quot;callback hell&quot; y permitiendo un mejor manejo de errores.</p>
<ul>
<li><strong>Async/Await</strong> <em>( Sintaxis para trabajar con promesas de manera síncrona )</em></li>
</ul>
<p>Es una sintaxis de JavaScript para trabajar con promesas de manera síncrona, haciéndolas parecer más como código síncrono. Las funciones marcadas con async devuelven automáticamente una promesa y la palabra clave await pausa la ejecución de la función hasta que la promesa se resuelve o se rechaza.</p>
<ul>
<li><strong>EventEmitted</strong> <em>( Clase para emitir y escuchar eventos )</em></li>
</ul>
<p>Es una clase en Node.js que permite la implementación de un patrón de diseño de publicación/suscripción para la gestión de eventos. Los objetos EventEmitter pueden emitir eventos y los oyentes pueden suscribirse a esos eventos para ejecutar código específico cuando se emiten.</p>
<ul>
<li><strong>Buffed</strong> <em>( Almacén temporal de datos binarios en memoria )</em></li>
</ul>
<p>Es un área de memoria que se utiliza para almacenar datos binarios de longitud fija. Los buffers son comúnmente utilizados en Node.js para trabajar con datos binarios como archivos, imágenes o datos de red.</p>
<ul>
<li><strong>Stream</strong> <em>( Flujo de datos que se procesa incrementalmente )</em></li>
</ul>
<p>Es una abstracción en Node.js para leer o escribir datos de manera secuencial. Los streams permiten procesar grandes volúmenes de datos de manera eficiente, ya que no es necesario cargar todo el contenido en memoria de una vez.</p>
<ul>
<li><strong>Cluste</strong> <em>( Módulo para crear procesos hijos en paralelo )</em></li>
</ul>
<p>El módulo Cluster en Node.js permite crear múltiples procesos hijos que comparten el mismo puerto del servidor. Esto mejora el rendimiento y la escalabilidad al permitir que un servidor Node.js utilice todos los núcleos de la CPU de manera eficiente.</p>
<ul>
<li><strong>N-AP</strong> <em>( Interfaz de aplicación nativa para extensiones C++ )</em></li>
</ul>
<p>Es una interfaz de aplicación nativa en Node.js que proporciona una forma estable de escribir extensiones en C++ que sean compatibles con múltiples versiones de Node.js. Esto facilita la creación de módulos nativos para Node.js que no dependen de la versión específica de Node.js.</p>
<ul>
<li><strong>Debugged</strong> <em>( Herramientas para depurar código Node.js )</em></li>
</ul>
<p>Debugger: Node.js ofrece herramientas integradas de depuración que permiten inspeccionar el estado de ejecución de una aplicación, establecer puntos de interrupción, rastrear variables y ejecutar el código paso a paso para identificar y corregir errores.</p>
<h1 id="comandos">Comandos</h1>
<h2 id="control-de-versiones-de-node">Control de versiones de Node</h2>
<pre><code class="language-bash">
nvm                           # controlador de version de Node.js
nvm install &lt;v nroVersion&gt;    # instala la version elegida
nvm list                      # muestra la versiones instaladas
nvm use &lt;v nroVersion&gt;        # activa la version elegida
nvm uninstall &lt;v nroVersion&gt;  # instala la version elegida
nvm alias default node        # usa la ultima version instalada

</code></pre>
<h2 id="comandos-basicos">Comandos Básicos</h2>
<pre><code class="language-bash">
node nomArch            # Ejecuta archivos JavaScript con Node.js.
node -V                 # Muestra la versión actual de Node.js instalada.
node --inspect nomArch  # Inicia la depuración de un archivo JavaScript.
node .&lt;comando&gt;         # es la consola en Node.js
comandos                # [ break, clear, editor, exit, help, load, sav ]

</code></pre>
<h2 id="comandos-de-npm-node-package-manager">Comandos de NPM (Node Package Manager)</h2>
<pre><code>
npm init                            # Crea un nuevo archivo package.json interactivo en el directorio actual.
npm i/install                       # Instala todas las dependencias listadas en package.json.
npm i/install &lt;package&gt;             # Instala un paquete específico y lo añade a package.json como DEPENDENCIA.
npm i/install &lt;package&gt; --save-dev  # Instala un paquete específico y lo añade a package.json como dev-dependencies.
npm un/uninstall &lt;package&gt;          # Desinstala un paquete específico y lo elimina de package.json.
npm run &lt;script&gt;                    # Ejecuta un script definido en la sección scripts de package.json.
npm ls/list                         # Muestra una lista de todos los paquetes instalados y sus dependencias.
npm outdate                         # Muestra una lista de paquetes desactualizado.
npm update &lt;package&gt;                # Actualiza todos los paquetes a sus versiones más recientes según las restricciones en package.json.
                                    # Se tiene que actualizar manualmente las DEPENDENCIA en el package.json
npm cache clean --forc              # Limpia la caché de npm.

</code></pre>
<h2 id="paquete-server">Paquete server</h2>
<pre><code class="language-bash">npm -i --g serve   # Es como live-server para Node.js
</code></pre>
<h2 id="comandos-de-npx">Comandos de NPX</h2>
<pre><code class="language-bash">npx &lt;command&gt;   # Ejecuta comandos npm sin necesidad de instalarlos globalmente.
</code></pre>
<h2 id="comandos-de-control-de-versiones">Comandos de Control de Versiones</h2>
<pre><code class="language-bash">nvm install 14.17.0   # instalar la versión n°
nvm use 14.17.0       # usar la versión n°
</code></pre>
<hr>
<h1 id="frameworks-express">Frameworks Express</h1>
<p><strong>Express</strong> es uno de los frameworks más populares para construir aplicaciones web con Node.js.<br>
<strong>Métodos:</strong> Routing / Middleware / Aplicación / Respuesta</p>
<h2 id="metodos-de-routing">Métodos de Routing</h2>
<p>Estos métodos se utilizan para definir las rutas y manejar las solicitudes HTTP.</p>
<h3 id="maneja-solicitudes-http">Maneja solicitudes HTTP</h3>
<h3 id="estados">estados</h3>
<table>
<thead>
<tr>
<th style="text-align:center">estados</th>
<th>data</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>100</strong></td>
<td>informativa</td>
</tr>
<tr>
<td style="text-align:center"><strong>200</strong></td>
<td>correctas</td>
</tr>
<tr>
<td style="text-align:center"><strong>300</strong></td>
<td>redirecciones</td>
</tr>
<tr>
<td style="text-align:center"><strong>400</strong></td>
<td>cliente</td>
</tr>
<tr>
<td style="text-align:center"><strong>500</strong></td>
<td>servidor</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><strong>GET</strong>: Se usa para <em><strong>OBTENER</strong></em> datos del servidor.</li>
</ul>
<pre><code class="language-js">app.get(path, callback);

app.get(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud GET&quot;);
});
</code></pre>
<ul>
<li><strong>POST</strong>: Se usa para <em><strong>ENVIAR</strong></em> datos al servidor.</li>
</ul>
<pre><code class="language-js">app.post(path, callback);

app.post(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud POST&quot;);
});
</code></pre>
<ul>
<li><strong>PUT</strong>: Se usa para <em><strong>ACTUALIZAR</strong></em> datos en el servidor.</li>
</ul>
<pre><code class="language-js">app.put(path, callback);

app.put(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud PUT&quot;);
});
</code></pre>
<ul>
<li><strong>DELETE</strong>: Se usa para <em><strong>ELIMINAR</strong></em> datos del servidor.</li>
</ul>
<pre><code class="language-js">app.delete(path, callback);

app.delete(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud DELETE&quot;);
});
</code></pre>
<ul>
<li><strong>PATCH</strong>: Se usa para <em><strong>realizar</strong></em> ACTUALIZACIONES * PARCIALES de los datos.</li>
</ul>
<pre><code class="language-js">app.patch(path, callback);

app.patch(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud PATCH&quot;);
});
</code></pre>
<ul>
<li><strong>All</strong>: Maneja todas las <strong>solicitudes</strong> HTTP para UNA ruta <em><strong>específica</strong></em>.</li>
</ul>
<pre><code class="language-js">app.all(path, callback);

app.all(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a cualquier tipo de solicitud HTTP&quot;);
});
</code></pre>
<h2 id="metodos-de-middleware">Métodos de Middleware</h2>
<p>Estos métodos se usan para ejecutar código antes de llegar a la ruta específica.
Es extremadamente útil para organizar y modularizar la lógica de la aplicación, permitiendo añadir funcionalidades comunes de manera eficiente y estructurada.
Aplica middleware a todas las rutas que coinciden con el path especificado.</p>
<pre><code class="language-js">
app.use(middleware):    # Aplica middleware a todas las rutas de la aplicación.

app.use(path, middleware);

app.use(&quot;/ruta&quot;, (req, res, next) =&gt; {
  console.log(&quot;Middleware ejecutado&quot;);
  next();
});

app.use((req, res, next) =&gt; {
  console.log(&quot;Middleware ejecutado para todas las rutas&quot;);
  next();
});

</code></pre>
<h2 id="metodos-de-aplicacion">Métodos de Aplicación</h2>
<p>Estos métodos se usan para configurar y manejar la aplicación.</p>
<ul>
<li><strong>Listen</strong>: Inicia el servidor en el puerto especificado.</li>
</ul>
<pre><code class="language-js">app.listen(port, callback):

app.listen(3000, () =&gt; {
  console.log(&quot;Servidor escuchando en el puerto 3000&quot;);
});
</code></pre>
<ul>
<li><strong>Set</strong>: Establece una variable de configuración.</li>
</ul>
<pre><code class="language-js">app.set(name, value):

app.set(&quot;view engine&quot;, &quot;ejs&quot;);
</code></pre>
<ul>
<li><strong>Get</strong>: Obtiene una variable de configuración.</li>
</ul>
<pre><code class="language-js">app.get(name):

const engine = app.get(&quot;view engine&quot;);
</code></pre>
<h2 id="metodos-de-respuesta">Métodos de Respuesta</h2>
<p>Estos métodos se usan para enviar respuestas al cliente.</p>
<ul>
<li><strong>Send</strong>: Envía una respuesta de varios tipos al cliente.</li>
</ul>
<pre><code class="language-js">res.send(data);

res.send(&quot;Hola, mundo&quot;);
</code></pre>
<ul>
<li><strong>Json</strong>: Envía una respuesta en formato JSON.</li>
</ul>
<pre><code class="language-js">res.json(data);

res.json({ mensaje: &quot;Hola, mundo&quot; });
</code></pre>
<ul>
<li><strong>Status</strong>: Establece el código de estado HTTP para la respuesta.</li>
</ul>
<pre><code class="language-js">res.status(code);

res.status(404).send(&quot;No encontrado&quot;);
</code></pre>
<ul>
<li><strong>Redirect</strong>: Redirige la solicitud a una URL diferente.</li>
</ul>
<pre><code class="language-js">res.redirect(url);

res.redirect(&quot;/nueva-ruta&quot;);
</code></pre>
<ul>
<li><strong>Render</strong>: Renderiza una vista utilizando el motor de plantillas configurado.</li>
</ul>
<pre><code class="language-js">res.render(view, data);

res.render(&quot;index&quot;, { titulo: &quot;Página de Inicio&quot; });
</code></pre>
<h4 id="estos-metodos-son-fundamentales-para-trabajar-con-express-y-permiten-manejar-y-responder-a-las-solicitudes-http-de-manera-efectiva">Estos métodos son fundamentales para trabajar con Express y permiten manejar y responder a las solicitudes HTTP de manera efectiva.</h4>

    </main>
    <hr>
    <aside>
      <h2 id="categorias">Categorías</h2>
      <h3 id="otros-articulos">Otros artículos</h3>
      <ul>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/HTMLMd/">
              HTML
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/JavaScript/">
              JavaScript
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/NodeMd/">
              Node.js
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/MarkdownMd/">
              Markdown
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/GitMd/">
              Git
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/ReactMd/">
              React
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/EleventyMd/">
              Eleventy
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_NodeMd/">
              X-Node.js
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_HTMLMd/">
              X-HTML
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_MarkdownMd/">
              X-Markdown
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_GitMd/">
              X-Git
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_ReactMd/">
              X-React
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_EleventyMd/">
              X-Eleventy
            </a>
          </li>
        
      </ul>
    </aside>
    <footer>
  <p>Diseño hecho ©2024 Fernando Sosa</p>
</footer>
    <script src="/blog-lenguajes-eleventy/js/main.js" type="module"></script>
  </body>
</html>