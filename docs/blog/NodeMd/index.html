<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js</title>
    <meta name="description" content="Ideas principales de Node.js">
    <link rel="icon" href="/blog-lenguajes-eleventy/img/icono.ico">
    <link rel="stylesheet" href="/blog-lenguajes-eleventy/css/styles-post.css">
  </head>
  <body>
    <header>
  <nav class="navbar">
  <div class="grir-parent">
    <div class="grid-item">
      <a href="/blog-lenguajes-eleventy/" class="logo"> FerBlog </a>
      <div class="menu">
          <a href="/blog-lenguajes-eleventy/">Inicio</a>
          <a href="/blog-lenguajes-eleventy/blog">Blog</a>
      </div>
    </div>
  </div>
</nav>
</header>
    <main>
      <h1 id="node-js">Node.js</h1>
<p><img src="/blog-lenguajes-eleventy/img/portada/node.avif" alt="Node.js"></p>
<blockquote>
<p>Es un entorno de ejecución de JavaScript en el lado del servidor que permite a los desarrolladores crear aplicaciones web y de red altamente escalables y eficientes. Aquí tienes algunos conceptos básicos.</p>
</blockquote>
<h2 id="que-es-node">¿Qué es Node?</h2>
<p>Es un entorno de ejecución de JavaScript del lado del servidor basado en el motor V8 de Google Chrome.</p>
<h3 id="para-que-sirve-node">¿Para qué sirve Node?</h3>
<p>Permite ejecutar JavaScript fuera del navegador, principalmente para crear servidores, APIs, aplicaciones en tiempo real y herramientas de línea de comandos.</p>
<h3 id="diferencia-principal-entre-node-y-javascript">Diferencia principal entre Node y JavaScript</h3>
<p><strong>JavaScript:</strong> Lenguaje de programación.<br>
<strong>Node.js:</strong> Entorno que permite ejecutar JavaScript en el servidor, con módulos propios (fs, http, etc.) que no existen en el navegador.</p>
<h3 id="que-se-puede-hacer-con-node-js">¿Qué se puede hacer con Node.js?</h3>
<p>APIs REST y GraphQL
Aplicaciones en tiempo real (chat, juegos, sockets)
Microservicios
Automatización de tareas
Backend para aplicaciones web y móviles</p>
<h3 id="buenas-practicas-en-node-js">Buenas prácticas en Node.js</h3>
<p>Separar la lógica en controladores, rutas y servicios
Manejo de errores centralizado
Uso de middlewares
Variables de entorno (dotenv)
Validación de datos de entrada
Logs y monitoreo
Testeo automatizado</p>
<hr>
<h2 id="conceptos-relacionados">Conceptos relacionados</h2>
<h3 id="que-es-un-orm">¿Qué es un ORM?</h3>
<p>Object Relational Mapper: herramienta que permite interactuar con bases de datos usando objetos y métodos en lugar de SQL directo (ejemplo: Sequelize, TypeORM, Prisma).</p>
<h3 id="que-es-una-api">¿Qué es una API?</h3>
<p>Application Programming Interface: conjunto de reglas que permite que dos aplicaciones se comuniquen. En el contexto web suele ser un servicio que expone datos y funcionalidades.</p>
<h3 id="diferencia-entre-libreria-y-framework">Diferencia entre librería y framework</h3>
<p><strong>Librería</strong>: conjunto de funciones o utilidades que el programador decide cuándo y cómo usar (ej: Lodash).<br>
<strong>Framework</strong>: establece una estructura y un flujo de trabajo donde tu código se adapta al framework (ej: Express, NestJS).</p>
<h3 id="que-es-el-patron-rest">¿Qué es el patrón REST?</h3>
<p>Estilo de arquitectura para construir APIs que utiliza <code>HTTP</code> y operaciones como <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> siguiendo convenciones en las rutas y respuestas.</p>
<h3 id="que-es-serverless">¿Qué es Serverless?</h3>
<p>Modelo en el que no administras servidores, sino que el proveedor (ej: AWS Lambda, Firebase Functions) ejecuta funciones bajo demanda y escala automáticamente.</p>
<h3 id="que-es-arquitectura-de-microservicios">¿Qué es arquitectura de Microservicios?</h3>
<p>Es un estilo donde una aplicación grande se divide en pequeños servicios independientes, cada uno con su propia lógica y base de datos, que se comunican entre sí (generalmente vía APIs).</p>
<hr>
<h2 id="herramientas-y-seguridad">Herramientas y Seguridad</h2>
<h3 id="que-es-swagger-y-que-estandar-utiliza">¿Qué es Swagger y qué estándar utiliza?</h3>
<p>Es una herramienta para documentar y probar APIs REST. Utiliza el estándar OpenAPI Specification (OAS).</p>
<h3 id="para-que-sirve-cors-en-un-api-rest-cross-origin-resource-sharing">¿Para qué sirve CORS en un API REST? <em>( Cross-Origin Resource Sharing )</em></h3>
<p>Mecanismo que controla qué dominios pueden consumir tu API, previniendo accesos no autorizados desde otros orígenes.</p>
<h3 id="que-es-jwt-json-web-token">¿Qué es JWT? <em>( JSON Web Token )</em></h3>
<p>Estándar para transmitir información segura entre cliente y servidor en forma de token firmado digitalmente (usado en autenticación).</p>
<hr>
<h2 id="control-de-versiones-y-sql">Control de versiones y SQL</h2>
<h3 id="que-es-gitflow-y-como-se-utiliza">¿Qué es GitFlow y cómo se utiliza?</h3>
<p>• Permite organizar equipos y releases de software.
Estrategia de ramas en Git:</p>
<table>
<thead>
<tr>
<th style="text-align:center">ramas</th>
<th>componente</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main</td>
<td>Código en Producción</td>
</tr>
<tr>
<td style="text-align:center">hotfix</td>
<td>Correcciones Urgentes</td>
</tr>
<tr>
<td style="text-align:center">release</td>
<td>Versiones previas a producción</td>
</tr>
<tr>
<td style="text-align:center">develop</td>
<td>Integra todas las funcionalidades</td>
</tr>
<tr>
<td style="text-align:center">feature</td>
<td>Nuevas funcionalidades</td>
</tr>
</tbody>
</table>
<h3 id="diferencia-entre-funcion-y-proceso-almacenado-en-sql">Diferencia entre función y proceso almacenado en SQL</h3>
<p><strong>Función</strong>: retorna un valor y puede usarse en consultas (SELECT). Generalmente no modifica datos.<br>
<strong>Procedimiento almacenado (Stored Procedure)</strong>: conjunto de sentencias SQL que pueden ejecutar operaciones más complejas (insertar, actualizar, borrar) y no necesariamente devuelven un valor.</p>
<hr>
<h2 id="conceptos-importantes">Conceptos Importantes</h2>
<ul>
<li><strong>Modelo cliente / servidor</strong>: solicitudes</li>
<li><strong>Patrón de software</strong>: MVC (modelo vista controlador)</li>
<li><strong>API REST</strong>: CRUD: GET / POST / PUT / DELETE</li>
</ul>
<h2 id="conceptos-basicos">Conceptos Básicos</h2>
<ul>
<li><strong>Entorno de Ejecución</strong>: <em>( Ejecución de JavaScript en servidor )</em></li>
</ul>
<p>Node.js proporciona un entorno de tiempo de ejecución para JavaScript fuera del navegador, lo que significa que puedes ejecutar JavaScript en el servidor.</p>
<ul>
<li><strong>Event-Driven y Non-Blocking I/O</strong> <em>( Programación orientada a eventos, E/S no bloqueante )</em></li>
</ul>
<p>Node.js utiliza un modelo de programación orientado a eventos y operaciones de entrada/salida no bloqueante, lo que permite manejar múltiples solicitudes simultáneamente sin bloquear el hilo de ejecución.</p>
<ul>
<li><strong>Módulos</strong> <em>( División de la aplicación en módulos reutilizables )</em></li>
</ul>
<p>Node.js utiliza un sistema de módulos que permite la modularidad en el código. Puedes dividir tu aplicación en archivos pequeños y reutilizables, y luego importarlos según sea necesario en otros archivos.</p>
<ul>
<li><strong>npm: Node Package Manager</strong> <em>( Gestión de paquetes y dependencias con npm )</em></li>
</ul>
<p>Es el sistema de gestión de paquetes de Node.js que te permite instalar, compartir y gestionar dependencias de proyectos fácilmente. npm es una de las mayores colecciones de paquetes de código abierto del mundo.</p>
<ul>
<li><strong>API de E/S Asíncrona</strong> <em>( Operaciones de entrada/salida asíncronas )</em></li>
</ul>
<p>Node.js proporciona una amplia gama de APIs para realizar operaciones de entrada/salida de manera asíncrona, lo que significa que las operaciones pueden continuar mientras otras operaciones están en curso, sin bloquear el hilo de ejecución.</p>
<ul>
<li><strong>Single-Threaded pero Event-Loop</strong> <em>( Modelo de event-loop para concurrencia eficiente )</em></li>
</ul>
<p>Node.js opera en un solo hilo, pero utiliza un modelo de event-loop que permite manejar múltiples solicitudes simultáneamente. Esto hace que sea eficiente para aplicaciones de red en tiempo real.</p>
<ul>
<li><strong>Escalabilidad</strong> <em>( Altamente escalable para aplicaciones de red )</em></li>
</ul>
<p>Gracias a su modelo de E/S no bloqueante y su capacidad para manejar muchas conexiones simultáneas, Node.js es altamente escalable y adecuado para aplicaciones que requieren un alto rendimiento y concurrencia.</p>
<ul>
<li><strong>Desarrollo de API y Aplicaciones Web</strong> <em>( Desarrollo de APIs, servidores web, aplicaciones en tiempo real )</em></li>
</ul>
<p>Node.js es comúnmente utilizado para desarrollar APIs RESTful, servidores web y aplicaciones de una sola página (SPA), así como aplicaciones en tiempo real como chat en línea, juegos multijugador y aplicaciones de transmisión de datos.</p>
<ul>
<li><strong>Frameworks y Bibliotecas</strong> <em>( Utilización de frameworks y bibliotecas populares )</em></li>
</ul>
<p>Existen muchos frameworks y bibliotecas populares construidos sobre Node.js, como Express.js, Socket.io, Hapi.js, Koa.js, entre otros, que simplifican el desarrollo web y la creación de APIs.</p>
<ul>
<li><strong>Streaming de Datos</strong> <em>( Eficiente para streaming de datos en tiempo real )</em></li>
</ul>
<p>Node.js es excelente para el manejo de datos en tiempo real, como el streaming de archivos o la transmisión de video, debido a su capacidad para manejar la E/S de manera eficiente.</p>
<ul>
<li><strong>Middleware</strong> <em>( Funciones que manejan solicitudes HTTP intermedias )</em></li>
</ul>
<p>Son funciones intermedias que se ejecutan entre la recepción de una solicitud HTTP y el envío de una respuesta. En el contexto de Node.js y frameworks como Express.js, los middlewares pueden realizar tareas como el análisis del cuerpo de la solicitud, la autenticación, la gestión de sesiones, el registro de solicitudes, entre otros.</p>
<ul>
<li><strong>Callback</strong> <em>( Funciones pasadas como argumentos a otras funciones )</em></li>
</ul>
<p>En JavaScript, un callback es una función que se pasa como argumento a otra función y se ejecuta después de que la función principal ha terminado de ejecutarse. Son comunes en Node.js para manejar operaciones asíncronas como lectura de archivos, solicitudes de red o consultas a bases de datos.</p>
<ul>
<li><strong>Promesa</strong> <em>( Manejo asincrónico de operaciones, evita &quot;callback hell&quot; )</em></li>
</ul>
<p>Son objetos que representan el éxito o el fracaso eventual de una operación asíncrona y su valor resultante. Las promesas en Node.js proporcionan una forma más limpia y estructurada de manejar operaciones asincrónicas, evitando el &quot;callback hell&quot; y permitiendo un mejor manejo de errores.</p>
<ul>
<li><strong>Async/Await</strong> <em>( Sintaxis para trabajar con promesas de manera síncrona )</em></li>
</ul>
<p>Es una sintaxis de JavaScript para trabajar con promesas de manera síncrona, haciéndolas parecer más como código síncrono. Las funciones marcadas con async devuelven automáticamente una promesa y la palabra clave await pausa la ejecución de la función hasta que la promesa se resuelve o se rechaza.</p>
<ul>
<li><strong>EventEmitted</strong> <em>( Clase para emitir y escuchar eventos )</em></li>
</ul>
<p>Es una clase en Node.js que permite la implementación de un patrón de diseño de publicación/suscripción para la gestión de eventos. Los objetos EventEmitter pueden emitir eventos y los oyentes pueden suscribirse a esos eventos para ejecutar código específico cuando se emiten.</p>
<ul>
<li><strong>Buffed</strong> <em>( Almacén temporal de datos binarios en memoria )</em></li>
</ul>
<p>Es un área de memoria que se utiliza para almacenar datos binarios de longitud fija. Los buffers son comúnmente utilizados en Node.js para trabajar con datos binarios como archivos, imágenes o datos de red.</p>
<ul>
<li><strong>Stream</strong> <em>( Flujo de datos que se procesa incrementalmente )</em></li>
</ul>
<p>Es una abstracción en Node.js para leer o escribir datos de manera secuencial. Los streams permiten procesar grandes volúmenes de datos de manera eficiente, ya que no es necesario cargar todo el contenido en memoria de una vez.</p>
<ul>
<li><strong>Cluste</strong> <em>( Módulo para crear procesos hijos en paralelo )</em></li>
</ul>
<p>El módulo Cluster en Node.js permite crear múltiples procesos hijos que comparten el mismo puerto del servidor. Esto mejora el rendimiento y la escalabilidad al permitir que un servidor Node.js utilice todos los núcleos de la CPU de manera eficiente.</p>
<ul>
<li><strong>N-AP</strong> <em>( Interfaz de aplicación nativa para extensiones C++ )</em></li>
</ul>
<p>Es una interfaz de aplicación nativa en Node.js que proporciona una forma estable de escribir extensiones en C++ que sean compatibles con múltiples versiones de Node.js. Esto facilita la creación de módulos nativos para Node.js que no dependen de la versión específica de Node.js.</p>
<ul>
<li><strong>Debugged</strong> <em>( Herramientas para depurar código Node.js )</em></li>
</ul>
<p>Debugger: Node.js ofrece herramientas integradas de depuración que permiten inspeccionar el estado de ejecución de una aplicación, establecer puntos de interrupción, rastrear variables y ejecutar el código paso a paso para identificar y corregir errores.</p>
<h2 id="control-de-versiones-de-node">Control de versiones de Node</h2>
<pre><code class="language-bash">
nvm                           # controlador de version de Node.js
nvm install &lt;v nroVersion&gt;    # instala la version elegida
nvm list                      # muestra la versiones instaladas
nvm use &lt;v nroVersion&gt;        # activa la version elegida
nvm uninstall &lt;v nroVersion&gt;  # instala la version elegida
nvm alias default node        # usa la ultima version instalada

</code></pre>
<h2 id="comandos-basicos">Comandos Básicos</h2>
<pre><code class="language-bash">
node nomArch            # Ejecuta archivos JavaScript con Node.js.
node -V                 # Muestra la versión actual de Node.js instalada.
node --inspect nomArch  # Inicia la depuración de un archivo JavaScript.
node .&lt;comando&gt;         # es la consola en Node.js
comandos                # [ break, clear, editor, exit, help, load, sav ]

</code></pre>
<h2 id="comandos-de-npm-node-package-manager">Comandos de NPM (Node Package Manager)</h2>
<pre><code>
npm init                            # Crea un nuevo archivo package.json interactivo en el directorio actual.
npm i/install                       # Instala todas las dependencias listadas en package.json.
npm i/install &lt;package&gt;             # Instala un paquete específico y lo añade a package.json como DEPENDENCIA.
npm i/install &lt;package&gt; --save-dev  # Instala un paquete específico y lo añade a package.json como dev-dependencies.
npm un/uninstall &lt;package&gt;          # Desinstala un paquete específico y lo elimina de package.json.
npm run &lt;script&gt;                    # Ejecuta un script definido en la sección scripts de package.json.
npm ls/list                         # Muestra una lista de todos los paquetes instalados y sus dependencias.
npm outdate                         # Muestra una lista de paquetes desactualizado.
npm update &lt;package&gt;                # Actualiza todos los paquetes a sus versiones más recientes según las restricciones en package.json.
                                    # Se tiene que actualizar manualmente las DEPENDENCIA en el package.json
npm cache clean --forc              # Limpia la caché de npm.

</code></pre>
<h2 id="paquete-server">Paquete server</h2>
<pre><code class="language-bash">npm -i --g serve   # Es como live-server para Node.js
</code></pre>
<h2 id="comandos-de-npx">Comandos de NPX</h2>
<pre><code class="language-bash">npx &lt;command&gt;   # Ejecuta comandos npm sin necesidad de instalarlos globalmente.
</code></pre>
<h2 id="comandos-de-control-de-versiones">Comandos de Control de Versiones</h2>
<pre><code class="language-bash">nvm install 14.17.0   # instalar la versión n°
nvm use 14.17.0       # usar la versión n°
</code></pre>
<hr>
<h1 id="frameworks-express">Frameworks Express</h1>
<p><strong>Express</strong> es uno de los frameworks más populares para construir aplicaciones web con Node.js.<br>
<strong>Métodos:</strong> Routing / Middleware / Aplicación / Respuesta</p>
<h2 id="metodos-de-routing">Métodos de Routing</h2>
<p>Estos métodos se utilizan para definir las rutas y manejar las solicitudes HTTP.</p>
<h3 id="maneja-solicitudes-http">Maneja solicitudes HTTP</h3>
<h3 id="estados">estados</h3>
<table>
<thead>
<tr>
<th style="text-align:center">estados</th>
<th>data</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>100</strong></td>
<td>informativa</td>
</tr>
<tr>
<td style="text-align:center"><strong>200</strong></td>
<td>correctas</td>
</tr>
<tr>
<td style="text-align:center"><strong>300</strong></td>
<td>redirecciones</td>
</tr>
<tr>
<td style="text-align:center"><strong>400</strong></td>
<td>cliente</td>
</tr>
<tr>
<td style="text-align:center"><strong>500</strong></td>
<td>servidor</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><strong>GET</strong>: Se usa para <em><strong>OBTENER</strong></em> datos del servidor.</li>
</ul>
<pre><code class="language-js">app.get(path, callback);

app.get(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud GET&quot;);
});
</code></pre>
<ul>
<li><strong>POST</strong>: Se usa para <em><strong>ENVIAR</strong></em> datos al servidor.</li>
</ul>
<pre><code class="language-js">app.post(path, callback);

app.post(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud POST&quot;);
});
</code></pre>
<ul>
<li><strong>PUT</strong>: Se usa para <em><strong>ACTUALIZAR</strong></em> datos en el servidor.</li>
</ul>
<pre><code class="language-js">app.put(path, callback);

app.put(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud PUT&quot;);
});
</code></pre>
<ul>
<li><strong>DELETE</strong>: Se usa para <em><strong>ELIMINAR</strong></em> datos del servidor.</li>
</ul>
<pre><code class="language-js">app.delete(path, callback);

app.delete(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud DELETE&quot;);
});
</code></pre>
<ul>
<li><strong>PATCH</strong>: Se usa para <em><strong>realizar</strong></em> ACTUALIZACIONES * PARCIALES de los datos.</li>
</ul>
<pre><code class="language-js">app.patch(path, callback);

app.patch(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a una solicitud PATCH&quot;);
});
</code></pre>
<ul>
<li><strong>All</strong>: Maneja todas las <strong>solicitudes</strong> HTTP para UNA ruta <em><strong>específica</strong></em>.</li>
</ul>
<pre><code class="language-js">app.all(path, callback);

app.all(&quot;/ruta&quot;, (req, res) =&gt; {
  res.send(&quot;Respuesta a cualquier tipo de solicitud HTTP&quot;);
});
</code></pre>
<h2 id="metodos-de-middleware">Métodos de Middleware</h2>
<p>Estos métodos se usan para ejecutar código antes de llegar a la ruta específica.
Es extremadamente útil para organizar y modularizar la lógica de la aplicación, permitiendo añadir funcionalidades comunes de manera eficiente y estructurada.
Aplica middleware a todas las rutas que coinciden con el path especificado.</p>
<pre><code class="language-js">
app.use(middleware):    # Aplica middleware a todas las rutas de la aplicación.

app.use(path, middleware);

app.use(&quot;/ruta&quot;, (req, res, next) =&gt; {
  console.log(&quot;Middleware ejecutado&quot;);
  next();
});

app.use((req, res, next) =&gt; {
  console.log(&quot;Middleware ejecutado para todas las rutas&quot;);
  next();
});

</code></pre>
<h2 id="metodos-de-aplicacion">Métodos de Aplicación</h2>
<p>Estos métodos se usan para configurar y manejar la aplicación.</p>
<ul>
<li><strong>Listen</strong>: Inicia el servidor en el puerto especificado.</li>
</ul>
<pre><code class="language-js">app.listen(port, callback):

app.listen(3000, () =&gt; {
  console.log(&quot;Servidor escuchando en el puerto 3000&quot;);
});
</code></pre>
<ul>
<li><strong>Set</strong>: Establece una variable de configuración.</li>
</ul>
<pre><code class="language-js">app.set(name, value):

app.set(&quot;view engine&quot;, &quot;ejs&quot;);
</code></pre>
<ul>
<li><strong>Get</strong>: Obtiene una variable de configuración.</li>
</ul>
<pre><code class="language-js">app.get(name):

const engine = app.get(&quot;view engine&quot;);
</code></pre>
<h2 id="metodos-de-respuesta">Métodos de Respuesta</h2>
<p>Estos métodos se usan para enviar respuestas al cliente.</p>
<ul>
<li><strong>Send</strong>: Envía una respuesta de varios tipos al cliente.</li>
</ul>
<pre><code class="language-js">res.send(data);

res.send(&quot;Hola, mundo&quot;);
</code></pre>
<ul>
<li><strong>Json</strong>: Envía una respuesta en formato JSON.</li>
</ul>
<pre><code class="language-js">res.json(data);

res.json({ mensaje: &quot;Hola, mundo&quot; });
</code></pre>
<ul>
<li><strong>Status</strong>: Establece el código de estado HTTP para la respuesta.</li>
</ul>
<pre><code class="language-js">res.status(code);

res.status(404).send(&quot;No encontrado&quot;);
</code></pre>
<ul>
<li><strong>Redirect</strong>: Redirige la solicitud a una URL diferente.</li>
</ul>
<pre><code class="language-js">res.redirect(url);

res.redirect(&quot;/nueva-ruta&quot;);
</code></pre>
<ul>
<li><strong>Render</strong>: Renderiza una vista utilizando el motor de plantillas configurado.</li>
</ul>
<pre><code class="language-js">res.render(view, data);

res.render(&quot;index&quot;, { titulo: &quot;Página de Inicio&quot; });
</code></pre>
<h4 id="estos-metodos-son-fundamentales-para-trabajar-con-express-y-permiten-manejar-y-responder-a-las-solicitudes-http-de-manera-efectiva">Estos métodos son fundamentales para trabajar con Express y permiten manejar y responder a las solicitudes HTTP de manera efectiva.</h4>

    </main>
    <hr>
    <aside>
      <h2 id="categorias">Categorías</h2>
      <h3 id="otros-articulos">Otros artículos</h3>
      <ul>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/HTMLMd/">
              HTML
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/NodeMd/">
              Node.js
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/MarkdownMd/">
              Markdown
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/GitMd/">
              Git
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/ReactMd/">
              React
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/EleventyMd/">
              Eleventy
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_NodeMd/">
              X-Node.js
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_HTMLMd/">
              X-HTML
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_MarkdownMd/">
              X-Markdown
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_GitMd/">
              X-Git
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_ReactMd/">
              X-React
            </a>
          </li>
        
          <li>
            <a href="/blog-lenguajes-eleventy/blog/x_EleventyMd/">
              X-Eleventy
            </a>
          </li>
        
      </ul>
    </aside>
    <footer>
  <p>Diseño hecho ©2024 Fernando Sosa</p>
</footer>
    <script src="/blog-lenguajes-eleventy/js/main.js" type="module"></script>
  </body>
</html>